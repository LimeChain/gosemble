{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Gosemble Overview","text":"<p>Go implementation of Polkadot/Substrate compatible runtimes</p> <p>The following project is based on previous research funded by Web3 Foundation Grants and developed, and maintained by LimeChain, which provides conclusions if Go is a suitable choice for writing Polkadot Runtimes and further aids the development of a Go toolchain capable of producing compatible runtimes.</p> <p>While there are several implementations of Polkadot Hosts in Rust, C++, and Go, there is no other option than Rust for writing Polkadot Runtimes. And writing Polkadot Runtimes in Go is exciting, mainly because of Go's simplicity and automatic memory management.  It is a modern, powerful, and fast language, backed by Google and used in many of their software, thus making it an ideal candidate for implementing Polkadot Runtimes.</p>"},{"location":"build/build/","title":"Build","text":"<p>By utilizing our Toolchain, there are currently two options to choose from for the GC implementation. Modify the <code>GC</code> environment variable to switch between them.</p>"},{"location":"build/build/#extalloc-gc","title":"Extalloc GC","text":"<p>It works with the host's external allocator as per specification.</p> <pre><code>GC=\"\" make build\n</code></pre>"},{"location":"build/build/#conservative-gc","title":"Conservative GC","text":"<p>It is used only for development and testing and works by using a different heap base offset from the allocator's one (as a workaround) so that the GC can use a separate heap region for its allocations and not interfere with the allocator's region.</p> <pre><code>GC=\"conservative\" make build\n</code></pre>"},{"location":"build/inspect/","title":"Inspect","text":"<p>Install wasmer to get a simple view of the compiled WASM.</p> <pre><code>wasmer inspect build/runtime.wasm\n</code></pre> <p>To inspect the WASM in more detail, and view the actual memory segments, you can install wabt</p> <pre><code>wasm-objdump -x build/runtime.wasm\n</code></pre>"},{"location":"concepts/package-library/","title":"Package Library","text":"<ul> <li><code>build</code> - the output directory for the compiled Wasm file.</li> <li><code>config</code> - configuration of the used runtime modules (pallets).</li> <li><code>constants</code> - constants used in the runtime.</li> <li><code>env</code> - stubs for the host-provided functions.</li> <li><code>execution</code> - runtime execution logic.</li> <li><code>frame</code> - runtime modules (pallets).</li> <li><code>primitives</code> - runtime primitives.</li> <li><code>runtime</code> - runtime entry point and tests.</li> <li><code>utils</code> - utility functions.</li> <li><code>tinygo</code> - submodule for the Tinygo compiler, used for WASM compilation.</li> <li><code>goscale</code> - submodule for the SCALE codec.</li> <li><code>gossamer</code> - submodule for the Gossamer host, used during development and for running tests.</li> <li><code>substrate</code> - submodule for the Substrate host, used for running a network.</li> </ul>"},{"location":"concepts/runtime-architecture/","title":"Runtime Architecture","text":"<p>At the time of writing, the official Go compiler does not support Wasm compatible with the Polkadot/Substrate requirements. The proposed solution is based on an alternative Go compiler that aims at supporting Wasm runtimes compatible with Polkadot spec / Substrate that incorporates GC with external memory allocator targeting Wasm MVP.</p>"},{"location":"concepts/runtime-architecture/#webassembly-specification","title":"WebAssembly specification","text":"<p>It targets WebAssembly MVP without any extensions enabled, that offers limited set of features compared to WebAssembly 1.0. Adding on top of that, Polkadot/Substrate specifications for the Runtime module define very domain-specific API that consist of:</p> <ul> <li>imported Host provided functions for dealing with memory, storage, crypto, logging, etc.</li> <li>imported Host provided memory.</li> <li>exported linker specific globals (<code>__heap_base</code>, <code>__data_end</code>).</li> <li>exported <code>__indirect_function_table</code> (WIP and not enabled currently).</li> <li>exported business logic API functions (<code>Core_version</code>, <code>Core_execute_block</code>, <code>Core_initialize_block</code>, etc).</li> </ul> <p>Polkadot is a non-browser environment, but it is not an OS. It doesn't seek to provide access to an operating-system API like files, networking, or any other major part of the things provided by WASI (WebAssembly System Interface).</p>"},{"location":"concepts/runtime-architecture/#scale-codec","title":"SCALE codec","text":"<p>Runtime data, coming in the form of byte code, needs to be as light as possible. The SCALE codec provides the capability of efficiently encoding and decoding it. Since it is built for little-endian systems, it is compatible with Wasm environments. The runtime works with custom-defined SCALE types compatible with Tinygo. At the boundary where it interacts with the host (memory, storage), those are converted to ordinary Go types. </p>"},{"location":"concepts/runtime-architecture/#runtime-calls","title":"Runtime calls","text":"<p>Each function call into the Runtime is done with newly allocated memory (via the shared allocator), either for sharing input data or results. Arguments are SCALE encoded into a byte array and copied into this section of the Wasm shared memory. Allocations do not persist between calls. It is important to note that the Runtime uses the same Host provided allocator for all heap allocations, so the Host is in charge of the Wasm heap memory management. Data passing to the Runtime API is always SCALE encoded, Host API calls on the other hand try to avoid all encoding.</p>"},{"location":"concepts/runtime-architecture/#gc-with-external-memory-allocator","title":"GC with external memory allocator","text":"<p>According to the Polkadot specification, the Wasm module does not include a memory allocator. It imports memory from the Host and relies on Host imported functions for all heap allocations. Since Go/TinyGo uses GC and manages its memory by itself, contrary to specification, a GC with external memory allocator is implemented in our Tinygo fork to meet the requirements of the Polkadot specification.</p> <p>The design in which allocation functions are on the Host side is dictated by the fact that some Host functions might return buffers of data of unknown size. That means that the Wasm code cannot efficiently provide buffers upfront.</p> <p>For example, let's examine the Host function that returns a given storage value. The storage value's size is not known upfront in the general case, so the Wasm caller cannot pre-allocate the buffer upfront. A potential solution is to first call the Host function without a buffer, which will return the value's size, and then do the second call passing a buffer of the required size. For some Host functions, caches could be put in place for mitigation, some other functions cannot be implemented in such model at all. To solve this problem, it was chosen to place the allocator on the Host side. However, this is not the only possible solution, as there is an ongoing discussion about moving the allocator into the Wasm: [1]. Notably, the allocator maintains some of its data structures inside the linear memory and some other structures outside.</p>"},{"location":"concepts/runtime-architecture/#stack","title":"Stack","text":"<p>Since WebAssembly has no stack introspection to scan the roots, it requires to use mirrored shadow stack in the linear memory, pushed/popped along with the machine stack, thus making it less efficient. Also the stack placement differs from the one compiled from Substrate/Rust and it is placed before the data section.</p>"},{"location":"concepts/runtime-architecture/#exported-globals","title":"Exported globals","text":"<p>It is expected from the Runtime to export <code>__heap_base</code> global indicating the beginning of the heap. It is used by the Host allocator to prevent memory allocations below that address and avoid clashes with the stack and data sections.</p>"},{"location":"concepts/runtime-architecture/#imported-vs-exported-memory","title":"Imported vs exported memory","text":"<p>Imported memory works a little better than exported memory since it avoids some edge cases, although it also has some downsides. Working with exported memory is almost certainly still supported and in fact, this is how it worked in the beginning. However, the current spec describes that memory should be made available to the Polkadot Runtime for import under the symbol name <code>memory</code>.</p>"},{"location":"concepts/runtime-architecture/#no-concurrency","title":"No concurrency","text":"<p>In Polkadot, parallelism is achieved through Parachains.</p>"},{"location":"concepts/toolchain/","title":"Toolchain","text":"<p>Since we use a modified version of TinyGo for compiling Go to Wasm, some of Go's language capabilities can not be applied due to the limited support in Tinygo which also affects some of the design decisions.</p>"},{"location":"install/install/","title":"Install","text":"<p>Prerequisites</p> <ul> <li>Git</li> <li>Go 1.19+</li> <li>Docker</li> </ul> <p>Clone the Gosemble repository.</p> <pre><code>git clone https://github.com/LimeChain/gosemble.git\ncd gosemble\n</code></pre> <p>Pull all necessary git submodules.</p> <pre><code>git submodule update --init --recursive\n</code></pre>"},{"location":"reference/resources/","title":"Resources","text":""},{"location":"reference/resources/#polkadot","title":"Polkadot","text":"<ul> <li>General</li> <li>Wiki</li> <li>Specification</li> </ul>"},{"location":"reference/resources/#w3f","title":"W3F","text":"<ul> <li>Research</li> </ul>"},{"location":"reference/resources/#webassembly","title":"WebAssembly","text":"<ul> <li>Specification</li> </ul>"},{"location":"reference/resources/#go-tinygo","title":"Go / TinyGo","text":"<ul> <li>Go Docs</li> <li>TinyGo Docs</li> </ul>"},{"location":"test/debug/","title":"Debug","text":"<p>(TODO) showcase the logging capabilities of the runtime, and how to use them to debug the runtime execution.</p>"},{"location":"test/unit-test/","title":"Unit Test","text":"<p>After the Runtime is built, execute the tests with the help of Gossamer, which is used to import necessary Polkadot Host functionality and interact with the Runtime.</p> <pre><code>make test\n</code></pre> <p>or </p> <pre><code>make test_unit\nmake test_integration\n</code></pre>"},{"location":"tutorials/connect-to-polkadot-js/","title":"Connect to Polkadot.js","text":"<p>(TODO) add step by step instructions and screenshots</p>"},{"location":"tutorials/start-a-network/","title":"Start a Network","text":"<p>(TODO) add step by step instructions and screenshots</p> <pre><code>make start-network\n</code></pre>"}]}