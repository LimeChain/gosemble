{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview \ud83d\udc40","text":""},{"location":"#framework-for-building-parachains","title":"Framework for building Parachains \ud83c\udfa8","text":"<p>This is an alternative solution for building Polkadot/Substrate-compatible runtimes in Go. It aims to streamline the process of building a parachain with emphasis on simplicity and ease of use over configurability and feature richness.  It is designed to be straightforward to understand and use, while still providing the necessary tools to build a parachain.</p>"},{"location":"#why-choose-an-alternative-implementation-in-go","title":"Why choose an alternative implementation in Go \ud83c\udf31","text":"<p>While there are several implementations of Polkadot Hosts in Rust,  C++, and Go, the only option for writing Polkadot Runtimes is in Rust. Writing Polkadot Runtimes in Go is exciting, mainly because of Go's simplicity and automatic memory management. It is a modern, powerful, and fast language, backed by Google and used in many of their software, thus making it an ideal candidate for implementing Polkadot Runtimes.</p>"},{"location":"#how-it-started","title":"How it started \ud83d\udca1","text":"<p>This project is a result of previous research, funded by Web3 Foundation Grants, and developed and maintained by LimeChain. The research provides conclusions if Go is a suitable choice for writing Polkadot Runtimes and further aids the development of a Go toolchain, capable of producing compatible runtimes.</p> <p>If you are new to Polkadot, please check our onboarding guide on how to get started with the project.</p>"},{"location":"development/api/","title":"Runtime API modules","text":"<p>Contains modules of the Runtime API Specification.</p>"},{"location":"development/api/#supported-modules","title":"Supported modules","text":"Name Description AccountNonceApi Provides logic to get an account's nonce. AuraApi Manages block authoring AuRa consensus mechanism. Benchmarking Provides functionality for benchmarking extrinsic calls and system hooks. BlockBuilder Provides functionality for building and finalizing a block. Core Provides functionality for initialising and executing a block. GenesisBuilder Builds genesis configuration. GrandpaApi Manages the GRANDPA block finalization. Metadata Returns the metadata of the runtime OffchainWorkerApi Provides functionality to start offchain worker operations. SessionKeys Generates and decodes session keys TaggedTransactionQueue Validates transactions in the transaction queue. TransactionPaymentApi Queries the runtime for transaction fees. TransactionPaymentCallApi Queries the runtime for transaction call fees."},{"location":"development/api/#structure","title":"Structure","text":"<p>Each module must have the following:</p> <ul> <li><code>name</code></li> <li><code>version</code></li> <li><code>exported</code> runtime functions<ul> <li>Each runtime-exported function takes care of reading from and writing to the WASM memory.</li> </ul> </li> <li><code>metadata</code> definition</li> <li>Explanatory <code>inline documentation</code></li> </ul>"},{"location":"development/api/#example","title":"Example","text":"<p>An <code>example</code> module, which takes care of returning account balances.</p> <pre><code>package example\n\n// imports\n\n// Module implements the Example Runtime API.\ntype Module struct {\n    memUtils utils.WasmMemoryTranslator\n    logger   log.Logger\n}\n\nfunc New(logger log.Logger) Module {\n    return Module{\n        memUtils: utils.NewMemoryTranslator(),\n        logger:   logger,\n    }\n}\n\n// Name returns the name of the api module.\nfunc (m Module) Name() string {\n    return \"ExampleModule\"\n}\n\n// Item returns the first 8 bytes of the Blake2b hash of the name and version of the api module.\nfunc (m Module) Item() types.ApiItem {\n    hash := hashing.MustBlake2b8([]byte(ApiModuleName))\n    return types.NewApiItem(hash, apiVersion)\n}\n\n// AccountBalance returns the balance of given AccountId.\n// It takes two arguments:\n// - dataPtr: Pointer to the data in the Wasm memory.\n// - dataLen: Length of the data.\n// which represent the SCALE-encoded AccountId.\n// Returns a pointer-size of the SCALE-encoded balance of the account.\n// &lt;Link to Specification if found&gt;\nfunc (m Module) AccountBalance(dataPtr int32, dataLen int32) int64 {\n    b := m.memUtils.GetWasmMemorySlice(dataPtr, dataLen)\n    buffer := bytes.NewBuffer(b)\n\n    accountId, err := types.DecodeAccountId(buffer)\n    if err != nil {\n        m.logger.Critical(err.Error())\n    }\n\n    // Logic to get account balance\n\n    return m.memUtils.BytesToOffsetAndSize(accountBalance)\n}\n\n// Metadata returns the runtime api metadata of the module.\nfunc (m Module) Metadata() types.RuntimeApiMetadata {\n    // Metadata declaration of the module, which includes:\n    // * Name of the module\n    // * Definition of each runtime exported function (AccountBalance).\n    methods := sc.Sequence[types.RuntimeApiMethodMetadata]{\n        types.RuntimeApiMethodMetadata{\n            Name: \"account_balance\",\n            Inputs: sc.Sequence[types.RuntimeApiMethodParamMetadata]{\n                types.RuntimeApiMethodParamMetadata{\n                    Name: \"account\",\n                    Type: sc.ToCompact(metadata.TypesAddress32),\n                },\n            },\n            Output: sc.ToCompact(metadata.PrimitiveTypesU128),\n            Docs:   sc.Sequence[sc.Str]{\" Get current account balance of given `AccountId`.\"},\n        },\n    }\n\n    return types.RuntimeApiMetadata{\n        Name:    \"ExampleModule\",\n        Methods: methods,\n        Docs:    sc.Sequence[sc.Str]{\" The Example API to query account balances.\"},\n    }\n}\n</code></pre>"},{"location":"development/benchmarking/","title":"Benchmarking \u23f1\ufe0f","text":"<p>The goal of benchmarking is to determine how computationally heavy it is to execute a given operation, measured as time, which reflects the operation's computational complexity. The execution time is represented as weight, and 1 second of computation on a physical machine is equal to 10^12 weight units. This measure is used to limit the amount of work that can be done in a single block and to charge fees proportionally to the resources consumed by the operation.</p>"},{"location":"development/benchmarking/#process","title":"Process \ud83d\udccc","text":"<p>Gosemble includes a CLI that provides a way of executing benchmark tests in a configurable manner, including extrinsics, steps, repeatability, etc. As a result, it automatically generates the weight files. This functionality relies on a set of utility functions provided by both the runtime and the host (Gossamer), allowing to measure the execution time in an isolated manner. It also accounts for database reads and writes of the storage keys hit during execution (some keys are preloaded and thus are excluded from the counts). Here are the necessary steps to follow:</p>"},{"location":"development/benchmarking/#1-switch-the-host-branch","title":"1. Switch the host branch \ud83d\udd00","text":"<p>Checkout the host branch that contains the necessary functionality for benchmarking:</p> <pre><code>cd gossamer\ngit checkout bench-instance\n</code></pre> <p>Later, this set of functions provided by the host (Gossamer) is imported by the runtime and used during the benchmarking process.</p> <pre><code>\"env\".\"ext_benchmarking_current_time_version_1\": [] -&gt; [I64]\n\"env\".\"ext_benchmarking_set_whitelist_version_1\": [I64] -&gt; []\n\"env\".\"ext_benchmarking_reset_read_write_count_version_1\": [] -&gt; []\n\"env\".\"ext_benchmarking_start_db_tracker_version_1\": [] -&gt; []\n\"env\".\"ext_benchmarking_stop_db_tracker_version_1\": [] -&gt; []\n\"env\".\"ext_benchmarking_db_read_count_version_1\": [] -&gt; [I32]\n\"env\".\"ext_benchmarking_db_write_count_version_1\": [] -&gt; [I32]\n\"env\".\"ext_benchmarking_wipe_db_version_1\": [] -&gt; []\n\"env\".\"ext_benchmarking_commit_db_version_1\": [] -&gt; []\n\"env\".\"ext_benchmarking_store_snapshot_db_version_1\": [] -&gt; []\n\"env\".\"ext_benchmarking_restore_snapshot_db_version_1\": [] -&gt; []\n</code></pre>"},{"location":"development/benchmarking/#2-build-the-runtime","title":"2. Build the runtime \ud83c\udfd7\ufe0f","text":"<p>Build the runtime with the benchmarking feature:</p> <p><pre><code>make build-benchmarking\n</code></pre> or <pre><code>make build-docker-benchmarking\n</code></pre></p> <p>It exposes additional utility functions exported by the runtime, which allow the execution of benchmark tests in a Wasm environment.</p> <pre><code>\"Benchmark_dispatch\": [I32, I32] -&gt; [I64]\n\"Benchmark_hook\": [I32, I32] -&gt; [I64]\n</code></pre>"},{"location":"development/benchmarking/#3-write-benchmarks","title":"3. Write benchmarks \ud83d\udcdd","text":"<p>It is important to note that benchmark tests should always assess the worst-case scenario. The general process of writing a benchmark test includes setting up an initial state, executing an operation, and asserting the final state, which encompasses both success and failure scenarios.</p>"},{"location":"development/benchmarking/#31-dispatch-calls","title":"3.1. Dispatch calls \ud83d\udcde","text":"<ul> <li> <p>Example benchmark test: benchmark_timestamp_set_test.go</p> </li> <li> <p>Example benchmark test with linear components: runtime/benchmark_system_remark_test.go</p> </li> </ul> <p>Extrinsic calls are executed through the <code>Benchmark_dispatch</code> runtime function.</p>"},{"location":"development/benchmarking/#32-system-hooks","title":"3.2. System hooks \ud83e\ude9d","text":"<ul> <li>Example benchmark test: benchmark_hooks_test.go</li> </ul> <p>System hooks are executed through the <code>Benchmark_hooks</code> runtime function.</p>"},{"location":"development/benchmarking/#33-block-overhead","title":"3.3. Block overhead \ud83e\uddca","text":"<ul> <li>Example benchmark test: overhead_test.go</li> </ul>"},{"location":"development/benchmarking/#4-run-benchmarks","title":"4. Run benchmarks \u25b6\ufe0f","text":"<p>Run extrinsic and hook benchmarks with auto-generating weight files (the default):</p> <pre><code>make benchmark\n</code></pre> <pre><code>make benchmark steps=50 repeat=100\n</code></pre> <p>Run the overhead benchmarks:</p> <pre><code>make benchmark-overhead\n</code></pre> <p>Run benchmarks without generating weight files:</p> <pre><code>GENERATE_WEIGHT_FILES=false make benchmark\nGENERATE_WEIGHT_FILES=false make benchmark-overhead\n</code></pre>"},{"location":"development/build/","title":"Build \ud83c\udfd7\ufe0f","text":"<p>By utilizing our Toolchain you can build the runtime through one of several methods.</p>"},{"location":"development/build/#1-build-with-docker","title":"1. Build with Docker \ud83d\udc33","text":"<pre><code>make build-docker-release\n</code></pre>"},{"location":"development/build/#2-build-with-local-tinygo","title":"2. Build with local TinyGo","text":"<pre><code>make build-release\n</code></pre>"},{"location":"development/file-structure/","title":"File structure \ud83d\udcc1","text":"<ul> <li>api - api interface providing access to the modules (pallets) functionality.</li> <li><code>benchmarking</code> - cli and utilities for running benchmark tests.</li> <li><code>build</code> - the output directory for the compiled Wasm file.</li> <li><code>constants</code> - constants used in the runtime.</li> <li><code>docs</code> - project documentation.</li> <li><code>env</code> - stubs for the host-provided functions.</li> <li><code>execution</code> - runtime execution logic.</li> <li>frame - runtime modules (pallets).</li> <li><code>hooks</code> - hooks implemented by the modules.</li> <li><code>mocks</code> - mock implementations for testing.</li> <li><code>primitives</code> - runtime primitive types and host functions.</li> <li><code>runtime</code> - runtime entry point and integration tests.</li> <li><code>utils</code> - utility functions.</li> <li><code>scripts</code> - scripts used during deployment.</li> <li><code>tinygo</code> - submodule for the TinyGo compiler, used for WASM compilation.</li> <li><code>goscale</code> - submodule for the SCALE codec.</li> <li><code>gossamer</code> - submodule for the Gossamer host, used during development and for running tests.</li> <li><code>polkadot-sdk</code> - submodule for the Substrate host, used for running a network.</li> </ul>"},{"location":"development/inspect/","title":"Inspect \ud83d\udd2c","text":"<p>Install wasmer to get a simple view of the compiled WASM.</p> <pre><code>wasmer inspect build/runtime.wasm\n</code></pre> <pre><code>Type: wasm\nSize: 873.2 KB\nImports:\n  Functions:\n    \"env\".\"ext_allocator_malloc_version_1\": [I32] -&gt; [I32]\n    \"env\".\"ext_allocator_free_version_1\": [I32] -&gt; []\n    \"env\".\"ext_crypto_secp256k1_ecdsa_recover_compressed_version_2\": [I32, I32] -&gt; [I64]\n    \"env\".\"ext_crypto_ed25519_generate_version_1\": [I32, I64] -&gt; [I32]\n    \"env\".\"ext_crypto_ed25519_verify_version_1\": [I32, I64, I32] -&gt; [I32]\n    \"env\".\"ext_crypto_sr25519_generate_version_1\": [I32, I64] -&gt; [I32]\n    \"env\".\"ext_crypto_sr25519_verify_version_2\": [I32, I64, I32] -&gt; [I32]\n    \"env\".\"ext_hashing_blake2_128_version_1\": [I64] -&gt; [I32]\n    \"env\".\"ext_hashing_blake2_256_version_1\": [I64] -&gt; [I32]\n    \"env\".\"ext_hashing_twox_128_version_1\": [I64] -&gt; [I32]\n    \"env\".\"ext_hashing_twox_64_version_1\": [I64] -&gt; [I32]\n    \"env\".\"ext_storage_append_version_1\": [I64, I64] -&gt; []\n    \"env\".\"ext_storage_clear_version_1\": [I64] -&gt; []\n    \"env\".\"ext_storage_clear_prefix_version_2\": [I64, I64] -&gt; [I64]\n    \"env\".\"ext_storage_exists_version_1\": [I64] -&gt; [I32]\n    \"env\".\"ext_storage_get_version_1\": [I64] -&gt; [I64]\n    \"env\".\"ext_storage_read_version_1\": [I64, I64, I32] -&gt; [I64]\n    \"env\".\"ext_storage_root_version_2\": [I32] -&gt; [I64]\n    \"env\".\"ext_storage_set_version_1\": [I64, I64] -&gt; []\n    \"env\".\"ext_storage_commit_transaction_version_1\": [] -&gt; []\n    \"env\".\"ext_storage_rollback_transaction_version_1\": [] -&gt; []\n    \"env\".\"ext_storage_start_transaction_version_1\": [] -&gt; []\n    \"env\".\"ext_trie_blake2_256_ordered_root_version_2\": [I64, I32] -&gt; [I32]\n    \"env\".\"ext_logging_log_version_1\": [I32, I64, I64] -&gt; []\n  Memories:\n    \"env\".\"memory\": not shared (20 pages..)\n  Tables:\n  Globals:\nExports:\n  Functions:\n    \"Core_version\": [I32, I32] -&gt; [I64]\n    \"Core_initialize_block\": [I32, I32] -&gt; [I64]\n    \"Core_execute_block\": [I32, I32] -&gt; [I64]\n    \"BlockBuilder_apply_extrinsic\": [I32, I32] -&gt; [I64]\n    \"BlockBuilder_finalize_block\": [I32, I32] -&gt; [I64]\n    \"BlockBuilder_inherent_extrinsics\": [I32, I32] -&gt; [I64]\n    \"BlockBuilder_check_inherents\": [I32, I32] -&gt; [I64]\n    \"TaggedTransactionQueue_validate_transaction\": [I32, I32] -&gt; [I64]\n    \"AuraApi_slot_duration\": [I32, I32] -&gt; [I64]\n    \"AuraApi_authorities\": [I32, I32] -&gt; [I64]\n    \"AccountNonceApi_account_nonce\": [I32, I32] -&gt; [I64]\n    \"TransactionPaymentApi_query_info\": [I32, I32] -&gt; [I64]\n    \"TransactionPaymentApi_query_fee_details\": [I32, I32] -&gt; [I64]\n    \"TransactionPaymentCallApi_query_call_info\": [I32, I32] -&gt; [I64]\n    \"TransactionPaymentCallApi_query_call_fee_details\": [I32, I32] -&gt; [I64]\n    \"Metadata_metadata\": [I32, I32] -&gt; [I64]\n    \"Metadata_metadata_at_version\": [I32, I32] -&gt; [I64]\n    \"Metadata_metadata_versions\": [I32, I32] -&gt; [I64]\n    \"SessionKeys_generate_session_keys\": [I32, I32] -&gt; [I64]\n    \"SessionKeys_decode_session_keys\": [I32, I32] -&gt; [I64]\n    \"GrandpaApi_grandpa_authorities\": [I32, I32] -&gt; [I64]\n    \"OffchainWorkerApi_offchain_worker\": [I32, I32] -&gt; [I64]\n    \"GenesisBuilder_create_default_config\": [I32, I32] -&gt; [I64]\n    \"GenesisBuilder_build_config\": [I32, I32] -&gt; [I64]\n  Memories:\n  Tables:\n    \"__indirect_function_table\": FuncRef (105..105)\n  Globals:\n    \"__heap_base\": I32 (constant)\n    \"__data_end\": I32 (constant)\n</code></pre> <p>To inspect the WASM in more detail, and view the actual memory segments, you can install wabt.</p> <pre><code>wasm-objdump -x build/runtime.wasm\n</code></pre>"},{"location":"development/install/","title":"Install \ud83d\udce6","text":"<p>Prerequisites</p> <ul> <li>Git</li> <li>Go 1.21</li> <li>Docker</li> <li>Rust (for building the Substrate node)</li> </ul> <p>Clone the Gosemble repository.</p> <pre><code>git clone https://github.com/LimeChain/gosemble.git\ncd gosemble\n</code></pre> <p>Pull all necessary git submodules.</p> <pre><code>git submodule update --init --recursive\n</code></pre>"},{"location":"development/metadata/","title":"Metadata","text":"<p>The Runtime Metadata consists of all the necessary information on how to interact with the Runtime. Given that runtimes are upgradeable, changes to runtimes are applied to their metadata as well.</p>"},{"location":"development/metadata/#supported-versions","title":"Supported versions","text":"<p>Gosemble supports the following versions:</p> <ul> <li>14 (default)</li> <li>15</li> </ul>"},{"location":"development/metadata/#generation-process","title":"Generation process","text":"<p>The original implementation of Gosemble Metadata was based on hard-coded definition types for all the necessary runtime types.</p> <p>After the codebase was refactored and modularised, we began generating the metadata definitions with the help of Go's <code>reflect</code> package. We introduced a  metadata generator, which builds and recursively adds the metadata type definitions.</p> <p>Implementation is under development.</p> <p>Currently, the metadata generator can generate metadata type definitions from:</p> <ul> <li>Go types</li> <li>A module's extrinsic calls</li> <li>A module's errors</li> <li>A module's constants</li> <li>Extrinsic signed extensions</li> </ul> <p>The goal is to add support for a module's storage types and remove all hard-coded definition types.</p>"},{"location":"development/metadata/#future-guidelines","title":"Future guidelines","text":"<p>We intend to refactor the metadata generation to be at compile-time.</p>"},{"location":"development/modules/","title":"Core Modules \ud83e\uddf1","text":"<p>Contains core modules that can be used and configured for runtime development and business logic.</p>"},{"location":"development/modules/#supported-modules","title":"Supported modules","text":""},{"location":"development/modules/#system-modules","title":"System modules","text":"Name Description executive A non-typical module, which wraps around the system module and provides functionality for block production and offchain workers. support A non-typical module, defining types for storage variables and logic for transactional layered execution. system Manages the core storage items of the runtime, such as extrinsic data, indices, event records. Executes block production and deposits logs."},{"location":"development/modules/#functional-modules","title":"Functional modules","text":"<p>These modules provide features than can be useful for your blockchain and can be plugged to your runtime code.</p> Name Description aura Manages the AuRa (Authority Round) consensus mechanism. balances Provides functionality for handling accounts and balances of native currency. grandpa Manages the GRANDPA block finalization. timestamp Manages on-chain time. transaction payment Manages pre-dispatch execution fees."},{"location":"development/modules/#structure","title":"Structure","text":"<p>Each module has the following structure:</p> <ul> <li><code>configuration</code> - types and parameters on which the module depends on.</li> <li><code>constants</code> - Constants and immutable parameters from the configuration.</li> <li><code>calls</code> - a set of extrinsic calls that define the module's functionality.</li> <li><code>errors</code> - dispatched during extrinsic calls execution.</li> <li><code>events</code> - declaration of events, emitted during extrinsic calls execution.</li> <li><code>genesis builder</code> - genesis configuration definition.</li> <li><code>storage</code> - lists all storage keys that can be modified by the given module during extrinsic call state transition.</li> <li><code>types</code> - type definitions for the module.</li> </ul>"},{"location":"development/modules/#file-structure","title":"File structure","text":"<p>We recommend the following structure for a module:</p> <pre><code>\u251c\u2500\u2500 frame\n\u2502   \u251c\u2500\u2500 &lt;module_name&gt; # Name of the module\n\u2502   \u2502   \u251c\u2500\u2500 call_1_.go # extrinsic call functionality for call 1\n\u2502   \u2502   \u251c\u2500\u2500 ...\n\u2502   \u2502   \u251c\u2500\u2500 call_N_.go # extrinsic call functionality for call N\n\u2502   \u2502   \u251c\u2500\u2500 config.go\n\u2502   \u2502   \u251c\u2500\u2500 constants.go\n\u2502   \u2502   \u251c\u2500\u2500 errors.go\n\u2502   \u2502   \u251c\u2500\u2500 events.go\n\u2502   \u2502   \u251c\u2500\u2500 genesis_builder.go\n\u2502   \u2502   \u251c\u2500\u2500 module.go # unites all the components of the module\n\u2502   \u2502   \u251c\u2500\u2500 storage.go\n\u2502   \u2502   \u251c\u2500\u2500 types.go\n\u2502   \u251c\u2500\u2500 &lt;module_name_2&gt;\n\u2502   \u2502   \u251c\u2500\u2500 ...\n\u2502   \u251c\u2500\u2500 ...\n</code></pre> <p>Unnecessary components of the module can be omitted.</p>"},{"location":"development/onboarding/","title":"Onboarding \ud83c\udf93","text":"<p>\ud83d\udcac\u00a0Please provide feedback on our onboarding guide. Let us know if any parts are unclear, confusing, or if you have other suggestions for improvement.</p> <p>The goal of this project is to develop a framework in Go that can be used by a Polkadot node.</p> <p>The Polkadot node is divided into two components, the Polkadot Runtime and the Polkadot Host. The Runtime handles the state transition logic for the Polkadot protocol and is designed to be upgradeable without the need of a fork. The Polkadot Host provides necessary functionality required for the Runtime to execute its state transition logic.</p> <p>Currently, Host implementations can be developed in Rust (Substrate), C++ (Kagome) and Go (Gossamer). On the other hand, Runtime can be developed only in Rust (Substrate).</p> <p>In this project, we focus only on the Runtime development in Go. The output of the Runtime code is Wasm bytecode, which can be plugged into any Host (you can consider this similar as how Solidity smart contracts are executed in Ethereum). The difference is that this bytecode takes care of the core functionality of a network.</p>"},{"location":"development/onboarding/#1-tech-stack","title":"1. Tech Stack \ud83d\udc98","text":""},{"location":"development/onboarding/#11-webassembly","title":"1.1. WebAssembly \ud83c\udfd7\ufe0f","text":"<p>WebAssembly (abbreviated as Wasm) is a binary instruction format for a stack-based virtual machine. It is designed as a compact, portable, and fast compilation target for high-level languages like C, C++, and Rust and many others that are being adapted. It enables execution of code at near-native speeds directly in web browsers and various host environments, as it resembles low-level machine code that modern CPUs understand.</p>"},{"location":"development/onboarding/#binary-format","title":"Binary Format","text":"<p>WebAssembly code is delivered in a low-level binary format, which is more compact than its textual representation. This binary format is designed to be fast to decode and execute. There's also a textual representation of this binary format, which is useful for debugging and testing.</p>"},{"location":"development/onboarding/#low-level-virtual-machine","title":"Low-Level Virtual Machine","text":"<p>WebAssembly provides a set of low-level virtual instructions that are closer to machine code than high-level programming languages. This enhances its execution efficiency and also makes it a suitable compilation target for other languages.</p>"},{"location":"development/onboarding/#typed-instructions","title":"Typed Instructions","text":"<p>WebAssembly instructions are strongly typed. It supports several numerical types like i32, i64, f32, and f64 and a few others for handling memory and tables.</p>"},{"location":"development/onboarding/#stack-based-architecture","title":"Stack-Based Architecture","text":"<p>Its computational model is designed around a stack-based architecture. Operations are performed by pushing and popping values from an implicit stack (the stack is inaccessible and distinct from the untrusted linear memory). Though it is not a pure stack machine, as it accommodates features like unlimited virtual registers (local variables).</p>"},{"location":"development/onboarding/#modules-sections","title":"Modules &amp; Sections","text":"<p>In the WebAssembly binary format, code and data are organized into modules. Each module consists of various sections arranged in a specific order, though some sections are optional. The module structure is defined by the WebAssembly specification and is validated before execution.</p> <ul> <li>Type Section - declares all function signatures used within the module.</li> <li>Import Section - specifies all module imports, such as functions, memories, globals, and tables.</li> <li>Function Section - contains a list of function declarations, each referencing the type section for its signature.</li> <li>Table Section - declares the table of function references used by the module.</li> <li>Global Section - declares global variables.</li> <li>Export Section - specifies all module exports, such as functions, memories, globals, and tables.</li> <li>Elem Section - initializes the table with function references for indirect function calls.</li> <li>Code Section - contains the binary code for the module's functions.</li> <li>Data Section - contains initial values for the module's memory.</li> <li>Custom Section - contains custom data for the host environment, possibly containing toolchain-specific information. This section can appear multiple times and is not restricted to a specific position in the list of sections.</li> </ul> <p>Modules can be dynamically loaded and combined, making it possible to build and manage larger applications effectively.</p>"},{"location":"development/onboarding/#memory-model","title":"Memory Model","text":"<p>WebAssembly uses a single contiguous byte buffer as its memory model, referred to as linear memory. This memory is resizable, byte-addressable and is accessible by all memory operations.</p> <p>Imported/Exported Memory</p> <p>It is isolated from the host system, thus providing a safe environment for the execution of untrusted code. It can be imported or exported, thus facilitates reading and writing operations by both WebAssembly and the Host.</p>"},{"location":"development/onboarding/#functions","title":"Functions","text":"<p>Every module may contain functions which can be either exported (made accessible outside the module) or imported (indicating dependency on an external function).</p> <p>Exported/Imported Functions</p> <p>The WebAssembly module and its Host communicate using host-imported and exported functions.</p> <p>Host-imported functions act as an additional bridge between WebAssembly and its host, enabling the module to access resources, input-output operations, or system-specific functionality. An example would be to get the time of the machine the Host is currently running on.</p> <p>On the other hand, exported functions enables customization, allowing developers to expose specific functionalities to the host environment. An example would be to export a runtime function, which takes care of the execution of blockchain transactions.</p>"},{"location":"development/onboarding/#webassembly-extensions","title":"WebAssembly Extensions","text":"<p>WebAssembly has a minimal core specification, but it's designed to be extensible. Proposals like threads, garbage collection, and SIMD (single instruction, multiple data) operations are being worked on or have been added to provide more capabilities over time.</p>"},{"location":"development/onboarding/#webassembly-javascript","title":"WebAssembly &amp; JavaScript","text":"<p>A significant feature of WebAssembly is its seamless interaction with JavaScript. The two can work in tandem within web applications.</p>"},{"location":"development/onboarding/#webassembly-wasi","title":"WebAssembly &amp; WASI","text":"<p>Beyond browser capabilities, with the introduction of the WebAssembly System Interface (WASI), it can be integrated into a wide range of environments (Host), including web applications, desktop software, and more. In our case, we are going to embed it into another Rust/Go/C++ application. This is achieved by the WebAssembly module exposing a well-defined interface, facilitating communication with the host.</p>"},{"location":"development/onboarding/#webassembly-mvp-polkadot","title":"WebAssembly MVP &amp; Polkadot","text":"<p>Polkadot uses a version of WebAssembly (Wasm MVP) that does not support reference types or multiple return types. Therefore, non-numeric values are exchanged through shared memory using pointer-sized allocations. This mechanism allows the WebAssembly module to interact manipulate data within the host's memory space, facilitating data exchange between the WebAssembly module and its host.</p> <p>In the case of Polkadot, the WebAssembly bytecode takes care of the state transition and block execution of each Polkadot Node, which is the most critical part. It is plugged into the Polkadot Node and it is called Runtime. In case of bugs, upgrades or updates, the logic can just be replaced with a new WebAssembly bytecode. This allows the Runtime to be updated on-chain, without the need of a network fork.</p> <ol> <li>Documentation</li> <li>Intro to WebAssembly</li> <li>Install latest Go (1.21) - https://go.dev/dl/ or brew</li> <li>Guides<ol> <li>Go to Wasm with JS apis - executed it in the browser</li> <li>Go to WASI</li> </ol> </li> </ol> <p>WebAssembly has different platform targets and extensions. Go supports Wasm depending on JavaScript supported APIs and with the release of Go 1.21, they\u2019ve added support for WASI.</p> <p>Unfortunately, Polkadot targets an old version of WebAssembly, called WebAssembly MVP, before spec version 1. This is why we will not use the Go toolchain for building wasm blobs, but TinyGo.</p>"},{"location":"development/onboarding/#12-go-and-tinygo","title":"1.2. Go and TinyGo \ud83e\udd96 \ud83d\udc23","text":"<p>TinyGo is a subset of Go with different goals from the standard Go. It is an alternative compiler and runtime aimed to support different small embedded devices and WebAssembly with a single processor core, emphasizing size optimizations.</p> <ol> <li>Documentation</li> <li>Install</li> <li>Guides<ol> <li>TinyGo to Wasm with JS apis - compile a Wasm module and execute it inside a JS environment (browser)</li> <li>TinyGo to WASI - compile a Wasm blob and execute it inside another Go host application (Wazero VM)<ol> <li>https://github.com/tetratelabs/wazero/tree/main/examples/allocation - check README and <code>tinygo</code> folder</li> <li>https://github.com/tetratelabs/wazero/tree/main/examples/import-go - check README</li> </ol> </li> </ol> </li> </ol>"},{"location":"development/onboarding/#13-tinygo-fork","title":"1.3. TinyGo fork \ud83e\uddea","text":"<p>We have forked TinyGo as we need to add a new target for the Polkadot-specific wasm blob, targeting standalone Wasm MVP, similar to Rust's <code>wasm32-unknown-unknown</code>, without bulk memory operations and other extensions, also incorporating custom GC that utilizes an external allocator. In the polkawasm-target-dev branch, you can see the changes for the specific TinyGo releases.</p> <ul> <li>Example: shows the changes added to TinyGo <code>v0.31</code>.</li> </ul> <p>We use a local build of TinyGo and do not depend on the already-built brew dependency.</p> <p>Here are the steps how to install and build it locally.</p> <p>After you have built TinyGo, execute the following:</p> <pre><code>tinygo version\n</code></pre> <p>The output should be similar to:</p> <pre><code>tinygo version 0.31.0-dev darwin/arm64 (using go version go1.21.6 and LLVM version 16.0.6)\n</code></pre>"},{"location":"development/onboarding/#2-architecture-of-a-polkadot-node","title":"2. Architecture of a Polkadot Node \ud83c\udfdb\ufe0f","text":"<p>Now that you have learned about WebAssembly, shared memory, runtime imported/exported functions and the TinyGo toolchain, let\u2019s look at the Polkadot specification.</p> <p>Polkadot node architecture and protocol specification is heavily influenced by the tech stack: WebAssembly MVP and Rust. Some implementation details, like the memory management, are not well abstracted and tightly coupled with the Rust implementation and even included as part of the protocol specification.</p>"},{"location":"development/onboarding/#21-node","title":"2.1. Node \ud83d\udcbb","text":"<p>Polkadot protocol has been divided into two parts, the Polkadot Runtime and the Polkadot Host.</p>"},{"location":"development/onboarding/#22-host-runtime-interaction","title":"2.2. Host-Runtime Interaction \ud83e\udd1d","text":""},{"location":"development/onboarding/#imported-functions","title":"Imported Functions \ud83d\udce5","text":"<p>External functions provided by the Host environment (Substrate/Kagome/Gossamer host) that Runtime (WebAssembly module) can invoke when needed, for more details check the Host API. The Host API provides access to memory, storage, crypto, hashing, logging and misc functionality.</p> <p>Example (Storage):</p> <ul> <li>Rust implementation using Substrate</li> <li>Go implementation using  Gosemble</li> </ul>"},{"location":"development/onboarding/#exported-functions","title":"Exported Functions \ud83d\udce4","text":"<p>Defined within the Runtime (WebAssembly module) and can be invoked by the Host application, for more details check the Runtime API.</p> <p>The Runtime API provides core and chains specific functionality.</p> <p>Example (Core API):</p> <ul> <li>Rust implementation using Substrate</li> <li>Go implementation using Gosemble</li> </ul>"},{"location":"development/onboarding/#memory","title":"Memory \ud83e\udde0","text":"<p>Shared between the Host and the Runtime and is managed by the Host allocator for all heap allocations. All data passed between Host and Runtime, like arguments to exported or imported functions or returned results, is encoded using SCALE encoding. Non numeric types, like byte buffers, are shared using a pointer-size to the allocation in the heap.</p> <ul> <li>SCALE encoding (Spec)</li> <li>SCALE Codec (Substrate)</li> </ul>"},{"location":"development/onboarding/#23-runtime-internals","title":"2.3. Runtime Internals \u2699\ufe0f","text":""},{"location":"development/onboarding/#extrinsics-transactions","title":"Extrinsics (Transactions) \ud83d\udcb3","text":"<ul> <li>Transaction Types</li> <li>Transaction Lifecycle</li> </ul>"},{"location":"development/onboarding/#weights-fees","title":"Weights &amp; Fees \u2696\ufe0f\u00a0\ud83d\udcb8","text":"<ul> <li>Transaction Weights (Gas) and Fees</li> </ul>"},{"location":"development/onboarding/#accounts-addresses-and-keys","title":"Accounts, addresses, and keys \ud83d\udc64\u00a0\ud83d\udd11","text":"<ul> <li>Accounts Addresses Keys</li> </ul>"},{"location":"development/onboarding/#storage","title":"Storage \ud83d\udcbe","text":"<p>Storing and retrieving data, key/value generation and types of storage values.</p> <ul> <li>State Transitions and Storage</li> <li>Transactional Storage</li> </ul>"},{"location":"development/onboarding/#pallets-modules","title":"Pallets (Modules) \ud83e\uddf1","text":"<p>Pallets communicate and interact with each other via events, storage, calls, hooks, etc.</p> <ul> <li>Pallet Coupling</li> <li>Events and Errors</li> </ul>"},{"location":"development/onboarding/#3-specifics-of-implementing-a-runtime-in-go","title":"3. Specifics of implementing a Runtime in Go \ud83d\udd0d\ud83d\udc1b","text":"<p>Developing a framework for writing Polkadot runtimes in Go is not a straight forward process, accompanied with many blockers and issues that need to be resolved. Most of the issues are related to the incompatibilities between the design decisions around the Polkadot protocol and the Go language. Here are some of the major challenges that we faced while working on the project:</p> <ul> <li>Missing support for standalone Wasm (MVP) \ud83d\udd73\ufe0f</li> <li>GC that is required to work with an external allocator, provided by the Host \ud83d\udca3</li> <li>Immature toolchain based on custom Tinygo \ud83d\udc23</li> <li>SCALE codec implementation with minimal reflection \ud83e\udea9</li> <li>Writing mostly low-level and unsafe Go (none of the concurrency capabilities are utilized) \u26a0\ufe0f</li> <li>The spec lacks details regarding the Runtime; thus, you should be able to read Rust code, which is the actual source of truth. \ud83e\udd80</li> </ul> <p>Most of the things are documented here Gosemble Runtime Architecture.</p>"},{"location":"development/onboarding/#4-tasks","title":"4. Tasks \ud83d\udcdd","text":""},{"location":"development/onboarding/#41-compile-a-runtime-from-gosemble-and-run-it-in-a-substrate-node","title":"4.1. Compile a Runtime from Gosemble and run it in a Substrate node \ud83d\udee0\ufe0f","text":"<ol> <li>Install <code>git</code> and <code>docker</code></li> <li>Clone the Gosemble repo - <code>git clone https://github.com/LimeChain/gosemble.git</code></li> <li>Checkout the development branch - <code>git checkout develop</code></li> <li>Pull all necessary git submodules - <code>git submodule update --init --recursive</code></li> <li>Build the runtime - <code>make build-docker-benchmarking</code></li> <li>Run the tests - <code>make test</code></li> <li>Start a local network - start a network</li> <li>Connect to Polkadot.js and do a simple transfer - transfer funds tutorial</li> </ol>"},{"location":"development/onboarding/#42-implement-simple-runtime-function-and-add-tests","title":"4.2. Implement simple Runtime function and add tests \ud83d\udee0\ufe0f","text":"<ol> <li>Declare a runtime exported function, example.</li> <li>Read a byte buffer passed as an argument, example.</li> <li>SCALE decode the byte buffer, example.</li> <li>Call 2-3 host imported functions, example, example.</li> <li>Return a byte buffer as a result, example.</li> <li>Add unit &amp; integration tests, example.</li> </ol>"},{"location":"development/test/","title":"Testing \ud83e\uddea","text":"<p>Currently, the project contains unit and integration tests. Integration tests use Gossamer, which imports all the necessary Host functions and interacts with the Runtime.</p> <pre><code>make test\n</code></pre> <p>or</p> <pre><code>make test-unit\nmake test-integration\n</code></pre>"},{"location":"development/test/#debug","title":"Debug \ud83d\udc1b","text":"<p>To aid the debugging process, there is a set of functions provided by the logger instance that can be called within the Runtime to log messages.</p> <pre><code>logger := log.NewLogger()\n\nlogger.Critical(message string) // logs and aborts the execution\nlogger.Warn(message string)\nlogger.Info(message string)\nlogger.Debug(message string)\nlogger.Trace(message string)\n</code></pre>"},{"location":"development/toolchain-setup/","title":"Toolchain \u2699\ufe0f","text":"<p>Given that we use our own custom version of the TinyGo compiler, to facilitate its development process, which includes making changes, building, and executing tests, it's necessary to carry out extra steps for setting up the development environment, beyond the initial requirements specified in the install page.</p>"},{"location":"development/toolchain-setup/#docker","title":"Docker","text":"<p>There is a docker image available, which can be used to build the compiler and run tests inside a container without having to install any dependencies locally. Run the following script to build and spin up a container:</p> <pre><code>cd tinygo\n./polkawasm.sh\n</code></pre>"},{"location":"development/toolchain-setup/#linux","title":"Linux","text":"<p>Similar to the Dockerfile.</p>"},{"location":"development/toolchain-setup/#macos-apple-silicon","title":"MacOS (Apple Silicon)","text":"<p>Install the necessary dependencies:</p> <pre><code>brew install cmake ninja\n</code></pre>"},{"location":"development/toolchain-setup/#build-tinygo-by-using-a-system-wide-llvm","title":"Build TinyGo by using a system-wide LLVM","text":""},{"location":"development/toolchain-setup/#install-llvm","title":"Install LLVM","text":"<p>Depending on the TinyGo version you want to build, choose the correct version of LLVM.  For example, TinyGo 0.31.0, requires LLVM 16:</p> <pre><code>brew install llvm@16\n</code></pre> <p>Make sure these environment variables are set correctly:</p> <pre><code>go env GOROOT # =&gt; /usr/local/go\ngo env GOPATH # =&gt; ~/go\ngo env GOARCH # =&gt; arm64\n</code></pre>"},{"location":"development/toolchain-setup/#build-wasi-libc","title":"Build Wasi-libc","text":"<p>To be able to build <code>wasi-libc</code>, for example without bulk memory operations, make sure LLVM is in your <code>PATH</code> environment variable. Add the following line to your <code>.zshrc</code>, <code>.bashrc</code>, or <code>.bash_profile</code> file:</p> <pre><code>export PATH=\"/opt/homebrew/opt/llvm@16/bin:$PATH\"\n</code></pre> <pre><code>make build-wasi-libc\n</code></pre>"},{"location":"development/toolchain-setup/#build-binaryen","title":"Build Binaryen","text":"<p>Specific version of <code>binaryen(wasm-opt)</code> is required to target the Wasm MVP instruction set:</p> <pre><code>make build-binaryen\n</code></pre>"},{"location":"development/toolchain-setup/#build-tinygo","title":"Build TinyGo","text":"<p>Use the Go toolchain to build TinyGo. Do not use <code>make</code>, since the <code>Makefile</code> is intended to be used with a self-built LLVM.</p> <pre><code>cd tinygo\ngo install\n</code></pre> <p>Make sure to include the path to the TinyGo binary in your <code>PATH</code> environment variable: </p> <pre><code>export PATH=\"$GOPATH/bin:$PATH\"\n</code></pre> <p>Restart the shell and verify it's working:</p> <pre><code>tinygo version\n</code></pre>"},{"location":"development/toolchain-setup/#run-tests","title":"Run Tests","text":"<pre><code># standard library packages that pass tests on darwin, linux, wasi, and windows, but take over a minute in wasi\ntinygo test -target wasi compress/bzip2 crypto/dsa index/suffixarray\n\n# standard library packages that pass tests quickly on darwin, linux, wasi, and windows\ntinygo test -target wasi compress/lzw compress/zlib container/heap container/list container/ring crypto/des crypto/md5 crypto/rc4 crypto/sha1 crypto/sha256 crypto/sha512 debug/macho embed/internal/embedtest encoding encoding/ascii85 encoding/base32 encoding/base64 encoding/csv encoding/hex go/scanner hash hash/adler32 hash/crc64 hash/fnv html internal/itoa internal/profile math math/cmplx net/http/internal/ascii net/mail os path reflect sync testing testing/iotest text/scanner unicode unicode/utf16 unicode/utf8\n\n# standard library packages that pass tests on individual platforms\ntinygo test -target wasi archive/zip bytes compress/flate crypto/hmac debug/dwarf debug/plan9obj image io/ioutil mime/quotedprintable net strconv testing/fstest text/tabwriter text/template/parse\n\n# wasi\ntinygo test -target wasi ./tests/runtime_wasi\n\n# wasm\ntinygo build -size short -o wasm.wasm -target=wasm examples/wasm/export\ntinygo build -size short -o wasm.wasm -target=wasm examples/wasm/main\n\n# wasm\ngo test -count=1 ./tests/wasm\n\ngo test -v -count=1 ./tests/os/smoke\ngo test -v -count=1 ./tests/runtime\ngo test -v -count=1 ./tests/text/template/smoke\ngo test -v -count=1 ./tests/tinygotest\n\ngo test -v -count=1 -v -timeout=20m -tags \"osusergo\" ./builder ./cgo ./compileopts ./compiler ./interp ./transform .\n</code></pre>"},{"location":"development/toolchain-setup/#build-tinygo-by-using-llvm-build-from-source","title":"Build TinyGo by using LLVM build from source","text":"<p>Use <code>make</code> with a self-built LLVM which has the benefit of already set up tests.</p> <p>Clone and build LLVM:</p> <pre><code>make llvm-source\nmake llvm-build\n</code></pre> <p>Build the TinyGo compiler:</p> <pre><code>make clean\nmake tinygo\n</code></pre> <p>Run the tests:</p> <pre><code>make test\nmake smoketest\nmake test-corpus-wasi\nmake wasmtest\n</code></pre>"},{"location":"overview/runtime-architecture/","title":"Architecture \ud83c\udfdb\ufe0f","text":"<p>At the time of writing, the official Go compiler is not Wasm compatible with the Polkadot/Substrate requirements. The proposed solution is based on an alternative Go compiler that aims at supporting Wasm runtimes compatible with Polkadot spec / Substrate that incorporates GC with external memory allocator targeting Wasm MVP.</p> <p></p>"},{"location":"overview/runtime-architecture/#webassembly-specification","title":"WebAssembly specification","text":"<p>It targets WebAssembly MVP without any extensions enabled, that offers limited set of features compared to WebAssembly 1.0. Adding on top of that, Polkadot/Substrate specifications for the Runtime module define very domain-specific API that consist of:</p> <ul> <li>imported Host provided functions for dealing with memory, storage, crypto, logging, etc.</li> <li>imported Host provided memory.</li> <li>exported linker specific globals (<code>__heap_base</code>, <code>__data_end</code>).</li> <li>exported <code>__indirect_function_table</code> (WIP and not enabled currently).</li> <li>exported business logic API functions (<code>Core_version</code>, <code>Core_execute_block</code>, <code>Core_initialize_block</code>, etc).</li> </ul> <p>Polkadot is a non-browser environment, but it is not an OS. It doesn't seek to provide access to an operating-system API like files, networking, or any other major part of the things provided by WASI (WebAssembly System Interface).</p>"},{"location":"overview/runtime-architecture/#scale-codec","title":"SCALE codec","text":"<p>Runtime data, coming in the form of byte code, needs to be as light as possible. The SCALE codec provides the capability of efficiently encoding and decoding it. Since it is built for little-endian systems, it is compatible with Wasm environments. The runtime works with custom-defined SCALE types compatible with TinyGo. At the boundary where it interacts with the host (memory, storage), those are converted to ordinary Go types.</p>"},{"location":"overview/runtime-architecture/#runtime-calls","title":"Runtime calls","text":"<p>Each function call into the Runtime is done with newly allocated memory (via the shared allocator), either for sharing input data or results. Arguments are SCALE encoded into a byte array and copied into this section of the Wasm shared memory. Allocations do not persist between calls. It is important to note that the Runtime uses the same Host provided allocator for all heap allocations, so the Host is in charge of the Wasm heap memory management. Data passing to the Runtime API is always SCALE encoded, Host API calls on the other hand try to avoid all encoding.</p>"},{"location":"overview/runtime-architecture/#gc-with-external-memory-allocator","title":"GC with external memory allocator","text":"<p>According to the Polkadot specification, the Wasm module does not include a memory allocator. It imports memory from the Host and relies on Host imported functions for all heap allocations. Since Go/TinyGo uses GC and manages its memory by itself, contrary to specification, a GC with external memory allocator is implemented in our TinyGo fork to meet the requirements of the Polkadot specification.</p> <p>However, this is not the only possible solution, as there are ongoing discussions about moving the allocator into the Wasm runtime:  [1] [2] </p>"},{"location":"overview/runtime-architecture/#stack","title":"Stack","text":"<p>Since WebAssembly has no stack introspection to scan the roots, it requires to use mirrored shadow stack in the linear memory, pushed/popped along with the machine stack, thus making it less efficient. Also, the stack placement differs from the one compiled from Substrate/Rust, and it is placed before the data section.</p>"},{"location":"overview/runtime-architecture/#exported-globals","title":"Exported globals","text":"<p>It is expected from the Runtime to export <code>__heap_base</code> global indicating the beginning of the heap. It is used by the Host allocator to prevent memory allocations below that address and avoid clashes with the stack and data sections.</p>"},{"location":"overview/runtime-architecture/#imported-vs-exported-memory","title":"Imported vs exported memory","text":"<p>Imported memory works a little better than exported memory since it avoids some edge cases, although it also has some downsides. Working with exported memory is almost certainly still supported and in fact, this is how it worked in the beginning. However, the current spec describes that memory should be made available to the Polkadot Runtime for import under the symbol name <code>memory</code>.</p>"},{"location":"overview/runtime-architecture/#no-concurrency","title":"No concurrency","text":"<p>In Polkadot, concurrency is achieved through Parachains.</p>"},{"location":"overview/toolchain/","title":"Toolchain \ud83d\udee0\ufe0f","text":"<p>Since we use toolchain based on modified version of TinyGo for compiling Go to Wasm, some of Go's language capabilities cannot be applied due to the limited support in TinyGo which also affects some of the design decisions.</p>"},{"location":"overview/toolchain/#1-tinygo-modifications","title":"1. TinyGo modifications","text":"<p>There are several changes made to TinyGo in order to make it compatible with Polkadot's Wasm target:</p>"},{"location":"overview/toolchain/#11-new-target","title":"1.1. New target \ud83c\udfaf","text":"<ul> <li><code>polkawasm</code> - targeting standalone Wasm MVP, similar to Rust's <code>wasm32-unknown-unknown</code>.</li> </ul>"},{"location":"overview/toolchain/#12-custom-garbage-collector","title":"1.2. Custom garbage collector \ud83d\uddd1\ufe0f","text":"<ul> <li><code>extalloc</code> - custom GC that utilizes an external allocator (as per Polkadot specification). It is conservative, tracing (mark and sweep) garbage collector that relies on an external memory allocator (via<code>ext_allocator_malloc</code>, <code>ext_allocator_free</code>) for the WebAssembly (<code>polkawasm</code>) target.</li> <li><code>extalloc_leaking</code> - leaking GC implementation that only allocates memory through the external allocator, but never frees it (not a real GC), however, it is useful for testing purposes and performance comparisons.</li> </ul>"},{"location":"overview/toolchain/#13-wasi-libc","title":"1.3. Wasi-libc \ud83d\udd29","text":"<ul> <li>fork with disabled bulk memory operations.</li> </ul>"},{"location":"overview/toolchain/#14-binaryen","title":"1.4. Binaryen \ud83d\udd29","text":"<ul> <li>version that lowers away the sign extension operations in <code>wasm-opt</code>.</li> </ul>"},{"location":"reference/resources/","title":"Resources \ud83d\udcda","text":""},{"location":"reference/resources/#polkadot","title":"Polkadot","text":"<ul> <li>Official Website</li> <li>Wiki</li> <li>Specification</li> <li>Forum</li> <li>Stack Exchange</li> </ul>"},{"location":"reference/resources/#substrate","title":"Substrate","text":"<ul> <li>Docs</li> </ul>"},{"location":"reference/resources/#w3f","title":"W3F","text":"<ul> <li>Research</li> </ul>"},{"location":"reference/resources/#github","title":"Github","text":"<ul> <li>Polkadot Fellowship</li> <li>Parity Technologies</li> </ul>"},{"location":"reference/resources/#webassembly","title":"WebAssembly","text":"<ul> <li>Specification</li> </ul>"},{"location":"reference/resources/#go-tinygo","title":"Go / TinyGo","text":"<ul> <li>Go Docs</li> <li>TinyGo Docs</li> </ul>"},{"location":"tutorials/start-a-network/","title":"Start a Network \ud83d\udd78\ufe0f","text":"<p>This tutorial provides a basic introduction how you can start a local network using Gosemble runtime, imported in Substrate node.</p>"},{"location":"tutorials/start-a-network/#before-you-begin","title":"Before you begin","text":"<p>Before you begin, verify that:</p> <ol> <li>You have installed all the repository dependencies.</li> <li>You have built your latest Gosemble runtime.</li> </ol>"},{"location":"tutorials/start-a-network/#build-and-start-the-network","title":"Build and start the network","text":"<ol> <li>Open a terminal shell on your machine.</li> <li>Change to the root directory to the locally cloned Gosemble repository.</li> <li>Execute the following command:</li> </ol> <pre><code>make start-network\n</code></pre> <p>This will build the Substrate node with the Gosemble runtime wasm blob and start a network with one node.</p> <p>Once the node is built, the terminal should display a similar output to this: <pre><code>2023-04-20 09:00:47 Substrate Node    \n2023-04-20 09:00:47 \u270c\ufe0f  version 4.0.0-dev-765fd435549    \n2023-04-20 09:00:47 \u2764\ufe0f  by Substrate DevHub &lt;https://github.com/substrate-developer-hub&gt;, 2017-2023    \n2023-04-20 09:00:47 \ud83d\udccb Chain specification: Development    \n2023-04-20 09:00:47 \ud83c\udff7  Node name: real-approval-9498    \n2023-04-20 09:00:47 \ud83d\udc64 Role: AUTHORITY    \n2023-04-20 09:00:47 \ud83d\udcbe Database: RocksDb at /var/folders/4y/0ylpyqgn22g8jqpchzpm6lz80000gn/T/substrateBtT4Ur/chains/dev/db/full    \n2023-04-20 09:00:47 \u26d3  Native runtime: node-template-100 (node-template-1.tx1.au1)    \n2023-04-20 09:00:47 \ud83d\udd28 Initializing Genesis block/state (state: 0x8cac\u20262784, header-hash: 0x3cda\u2026df57)    \n2023-04-20 09:00:47 \ud83d\udc74 Loading GRANDPA authority set from genesis on what appears to be first startup.    \n2023-04-20 09:00:47 Using default protocol ID \"sup\" because none is configured in the chain specs    \n2023-04-20 09:00:47 \ud83c\udff7  Local node identity is: 12D3KooWKTKaG1R7DxRtTWGAJDAEXC91QgbvjuW2HoChuarvPVwB    \n2023-04-20 09:00:47 \ud83d\udcbb Operating system: macos    \n2023-04-20 09:00:47 \ud83d\udcbb CPU architecture: aarch64    \n2023-04-20 09:00:47 \ud83d\udce6 Highest known block at #0    \n2023-04-20 09:00:47 \u303d\ufe0f Prometheus exporter started at 127.0.0.1:9615    \n2023-04-20 09:00:47 Running JSON-RPC HTTP server: addr=127.0.0.1:9933, allowed origins=[\"*\"]    \n2023-04-20 09:00:47 Running JSON-RPC WS server: addr=127.0.0.1:9944, allowed origins=[\"*\"]    \n2023-04-20 09:00:48 \ud83d\ude4c Starting consensus session on top of parent 0x3cda151b8ad3c4f331710e99d76c93a6f1332fb6944274beb4942758f129df57    \n2023-04-20 09:00:48 \ud83c\udf81 Prepared block for proposing at 1 (0 ms) [hash: 0x78f54ecfb1c9429ab0fdf79e895fe5b384996759fbad7dd080e86793cb6dd171; parent_hash: 0x3cda\u2026df57; extrinsics (1): [0x47a9\u20265266]]    \n2023-04-20 09:00:48 \ud83d\udd16 Pre-sealed block for proposal at 1. Hash now 0x73b64c2e2ebb1e36f6ce3ceae1f30db4e85ec97541cfca38f688771661283911, previously 0x78f54ecfb1c9429ab0fdf79e895fe5b384996759fbad7dd080e86793cb6dd171.    \n2023-04-20 09:00:48 \u2728 Imported #1 (0x73b6\u20263911)    \n2023-04-20 09:00:50 \ud83d\ude4c Starting consensus session on top of parent 0x73b64c2e2ebb1e36f6ce3ceae1f30db4e85ec97541cfca38f688771661283911    \n2023-04-20 09:00:50 \ud83c\udf81 Prepared block for proposing at 2 (0 ms) [hash: 0x8297614e7b45dde043902a55c76410ad249bdde1a34d30593a0614b0e7c8743c; parent_hash: 0x73b6\u20263911; extrinsics (1): [0x56e4\u2026ec44]]    \n2023-04-20 09:00:50 \ud83d\udd16 Pre-sealed block for proposal at 2. Hash now 0x46590bceeaf9c797c37e940b97dc7c127dfef625c540f32d3298570cdf805af1, previously 0x8297614e7b45dde043902a55c76410ad249bdde1a34d30593a0614b0e7c8743c.    \n2023-04-20 09:00:50 \u2728 Imported #2 (0x4659\u20265af1)    \n2023-04-20 09:00:52 \ud83d\ude4c Starting consensus session on top of parent 0x46590bceeaf9c797c37e940b97dc7c127dfef625c540f32d3298570cdf805af1    \n2023-04-20 09:00:52 \ud83c\udf81 Prepared block for proposing at 3 (1 ms) [hash: 0xc068b2a5904b34a40aeb0ee0ff64469a3879974435f36859c074542f11cacbd2; parent_hash: 0x4659\u20265af1; extrinsics (1): [0x2fc1\u20261556]]    \n2023-04-20 09:00:52 \ud83d\udd16 Pre-sealed block for proposal at 3. Hash now 0x1f95f1d3b05ee47883cc56853029b9160f0aedf966adc874e7acc50f64a1af1f, previously 0xc068b2a5904b34a40aeb0ee0ff64469a3879974435f36859c074542f11cacbd2.    \n2023-04-20 09:00:52 \u2728 Imported #3 (0x1f95\u2026af1f)    \n2023-04-20 09:00:52 \ud83d\udca4 Idle (0 peers), best: #3 (0x1f95\u2026af1f), finalized #0 (0x3cda\u2026df57), \u2b07 0 \u2b06 0    \n2023-04-20 09:00:54 \ud83d\ude4c Starting consensus session on top of parent 0x1f95f1d3b05ee47883cc56853029b9160f0aedf966adc874e7acc50f64a1af1f    \n2023-04-20 09:00:54 \ud83c\udf81 Prepared block for proposing at 4 (1 ms) [hash: 0xccb05a3ba5b0122223aceea63fdf451137f431eda74d3d5be071d033c276ad64; parent_hash: 0x1f95\u2026af1f; extrinsics (1): [0x3933\u2026768d]]    \n2023-04-20 09:00:54 \ud83d\udd16 Pre-sealed block for proposal at 4. Hash now 0x499abfe622f7ba16ee2f84d93d14cfd53cfb67ad6520c2fe1d4e494feabcba08, previously 0xccb05a3ba5b0122223aceea63fdf451137f431eda74d3d5be071d033c276ad64.    \n2023-04-20 09:00:54 \u2728 Imported #4 (0x499a\u2026ba08)    \n2023-04-20 09:00:56 \ud83d\ude4c Starting consensus session on top of parent 0x499abfe622f7ba16ee2f84d93d14cfd53cfb67ad6520c2fe1d4e494feabcba08    \n2023-04-20 09:00:56 \ud83c\udf81 Prepared block for proposing at 5 (1 ms) [hash: 0x1c360a200207e096b0b94888b35ef125636b79b7199051eb1d10e536233c1c98; parent_hash: 0x499a\u2026ba08; extrinsics (1): [0xdfad\u2026dc49]]    \n2023-04-20 09:00:56 \ud83d\udd16 Pre-sealed block for proposal at 5. Hash now 0x48285138338a30e15d38ffe6d972ce295d89c32b20f393034f2aec448abf348c, previously 0x1c360a200207e096b0b94888b35ef125636b79b7199051eb1d10e536233c1c98.    \n2023-04-20 09:00:56 \u2728 Imported #5 (0x4828\u2026348c)    \n...\n...\n...\n...\n2023-04-20 09:01:07 \ud83d\udca4 Idle (0 peers), best: #10 (0xa1fe\u2026c156), finalized #7 (0x2361\u202627a8), \u2b07 0 \u2b06 0   \n</code></pre></p> <p>If the number of <code>finalized</code> blocks is increasing, this means your blockchain network is producing new blocks and successfully reaching consensus.</p>"},{"location":"tutorials/transfer-funds/","title":"Transfer funds \ud83d\udcb8","text":"<p>This tutorial provides steps on how to issue a transfer transaction to your local network.</p> <p>After you have started the local network, let's make a transfer through the  Polkadot/Substrate Portal.</p> <ol> <li>Open https://polkadot.js.org/apps/.</li> <li> <p>Click the Polkadot logo.</p> <p></p> </li> <li> <p>Switch to local network</p> <ol> <li>Scroll down to Development tab. </li> <li>Open the Development tab and select Local Node.</li> <li>Click Switch.</li> </ol> <p></p> </li> <li> <p>Local Network Explorer</p> <p>If your page is similar to the image below, you have successfully connected to your local node. New  recent blocks should appear every 2 seconds.</p> <p></p> </li> <li> <p>Create a transfer transaction</p> <p>Now that you have connected to your local network, let's issue a transfer transaction. The network has preconfigured  4 addresses to have small balances. Let's see the Accounts first.</p> <ol> <li> <p>Hover over Accounts and click Accounts.</p> <p></p> </li> <li> <p>Now you see the balances of all the accounts. Let's issue a transfer from Alice. Click Send.</p> <p></p> </li> <li> <p>Send Transfer</p> <p>The transfer window should pop up. Let's set the send to address to be someone who has 0 balance.</p> <ol> <li>From the addresses dropdown, select Charlie.</li> <li>Input the amount to be 10000000.</li> <li> <p>Click Make Transfer.</p> <p></p> </li> <li> <p>Sign and Submit the transfer.</p> <p></p> </li> <li> <p>Once you have submitted the transfer, a green checkmark should appear in the top-right corner of your browser  window.</p> <p></p> <p>If you get a red cross, instead of a green checkmark, this means that most likely the transfer has failed. To understand why the transfer has failed, find the transaction in the node explorer.</p> </li> </ol> </li> </ol> </li> <li> <p>Inspect the transaction</p> <p>Now that the transfer has been successful, let's inspect the transfer:</p> <p></p> <p>There are 6 events related to the transfer:</p> <ul> <li>\u0422he withdrawal event, which takes the transaction fee from Alice.</li> <li>Charlie's account creation as his balance was 0 and did not exist previously on the network.</li> <li>An endowment to Charlie's balance.</li> <li>\u0422he actual transfer from Alice to Charlie.</li> <li>The transaction fee, paid by Alice.</li> <li>Last but not least, an event that showcases the transfer transaction has been successful.</li> </ul> </li> </ol>"}]}